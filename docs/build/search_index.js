var documenterSearchIndex = {"docs":
[{"location":"modules/rRBC.html#rotating-Rayleigh-Benard-convection-(rRBC)","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"","category":"section"},{"location":"modules/rRBC.html#Problem-setup","page":"rotating Rayleigh Benard convection (rRBC)","title":"Problem setup","text":"","category":"section"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"In this module, we do a linear stability analysis of a 2D rotating Rayleigh-Bernard case where the domain is periodic in the y-direction, in the x-direction is of infinite extent and vertically bounded. The reason to choose this simple case is because we can find an analytical solution for this case. The background temperature profile is given by ","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"overlinetheta = 1 - z","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"The non-dimensional form of the equations governing the perturbation is given by ","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"    fracEPr fracpartial mathbfupartial t \n    + hatz times mathbfu =\n    -nabla p + Ra theta hatz + E nabla^2 mathbfu","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"    fracpartial thetapartial t \n    = mathbfu cdot hatz + nabla^2 theta","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"    nabla cdot mathbfu = 0","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"where E=\\nu/(fH^2) is the Ekman number and Ra = g\\alpha \\Delta T/(f \\kappa), \\Delta T is the temperature difference between the bottom and the top walls) is the modified Rayleigh number. By applying the operators (\\nabla \\times \\nabla \\times) and (\\nabla \\times) and taking the z-component of the equations and assuming wave-like perturbations as done previously, we obtained the equations for vertical velocity w^, vertical vorticity \\zeta and temperature \\theta,","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"beginalign\n    E mathcalD^4 w - partial_z zeta = -Ra mathcalD_h^2 theta\n\n    E mathcalD^2 zeta + partial_z w = 0\n\n    mathcalD^2 b + w = 0\nendalign","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"The boundary conditions are: ","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"beginalign\n    w = partial_z^2 w = partial_z zeta = theta = 0\n     textat  z=01\nendalign","category":"page"},{"location":"modules/rRBC.html#Normal-mode","page":"rotating Rayleigh Benard convection (rRBC)","title":"Normal mode","text":"","category":"section"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"Next we consider normal-mode perturbation solutions in the form of (we seek stationary solutions at the marginal state, i.e., \\sigma = 0),","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"beginalign\n    w zeta theta(xyzt) =\nmathfrakRbig(tildew  tildezeta  tildetheta(y z)  e^i k x + sigma tbig)\nendalign","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction.  Finally following systems of differential equations are obtained,","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"beginalign\n    E mathcalD^4  tildew - partial_z tildezeta = - Ra mathcalD_h^2 tildetheta\n\n    E mathcalD^2 tildezeta + partial_z tildew = 0\n\n    mathcalD^2 tildetheta + tildew = 0 \nendalign","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"where ","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + partial_z^2 - k^2big)^2  textand  mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations ","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n   \n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e., ","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"beginalign\n    tildew = partial_zz tildew = \n    partial_z tildezeta = partial_z tildeb = 0 \n     textat  z=0 1\nendalign","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"beginalign\n    mathsfitA mathsfX= lambda mathsfitB mathsfX   \nendalign","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"where \\lambda=Ra is the eigenvalue. ","category":"page"},{"location":"modules/rRBC.html#Result","page":"rotating Rayleigh Benard convection (rRBC)","title":"Result","text":"","category":"section"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"For the parameter of E=10^{-4}, the obtained critical Rayleigh number Ra_c=1897 (matched with [chandrashekar]) analysis for horizontally infinite domain). Due to the finite aspect ratio, our stability analysis shows a finite number of convective rolls (below figure shows vertical velocity w) with y-wavenumber m_c=28, i.e., there are 28 pairs of rolls in the y-direction (below figure). According to [chandrashekar] analysis, the resultant wavenumber a_c=2802 for this parameter regime, and it can be shown that for a finite L_x, the resultant wavenumber a is related as","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"    a^2 = Big( frac2mpiL_y Big)^2 + k^2","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"where k is the x-wavenumber and in this analysis k=0.  So for L_y=2\\pi and a_c=28.02, we obtained m approx 28 which we also get from stability analysis.","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"(Image: Alt text)","category":"page"},{"location":"modules/rRBC.html","page":"rotating Rayleigh Benard convection (rRBC)","title":"rotating Rayleigh Benard convection (rRBC)","text":"[chandrashekar]: Chandrasekhar, S., 2013. Hydrodynamic and hydromagnetic stability. Courier Corporation.","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"\"\"\"\nStability of a 2D front based on Stone (1971)\n\"\"\"\n# load required packages\nusing LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing JLD2\nusing ModelingToolkit\nusing NonlinearSolve\n\nusing BiGSTARS\nusing BiGSTARS : FourierDiff, cheb_coord_transform_ho,\n\n@with_kw mutable struct TwoDimGrid{Ny, Nz}\n    y = @SVector zeros(Float64, Ny)\n    z = @SVector zeros(Float64, Nz)\nend\n\n@with_kw mutable struct ChebMarix{Ny, Nz}\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n\n    ğ’Ÿá¶»::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\nend\n\n@with_kw mutable struct Operator{N}\n\"\"\"\n    `subperscript with N' means Operator with Neumann boundary condition\n        after kronker product\n    `subperscript with D' means Operator with Dirchilet boundary condition\n        after kronker product\n\"\"\"\n\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÊ¸á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’ŸÊ¸Â²á¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸Â²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\nend\n\n@with_kw mutable struct MeanFlow{N}\n    Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n    Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡Ê¸Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡Ê¸Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡Ê¸Ê¸Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡Ê¸á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\nend","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"function Construct_DerivativeOperator!(diffMatrix, grid, params)     N = params.Ny * params.Nz","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"y1, diffMatrix.ğ’ŸÊ¸  = FourierDiff(params.Ny, 1)\ny2, d2y = FourierDiff(params.Ny, 2)\ndiffMatrix.ğ’ŸÂ²Ê¸ = d2y\n# y4, d4y = FourierDiff(params.Ny, 4)\n# diffMatrix.ğ’Ÿâ´Ê¸ = d4y\n\n# Transform the domain and derivative operators from [0, 2Ï€) â†’ [0, L)\ngrid.y         = params.L/2Ï€  * y1\ndiffMatrix.ğ’ŸÊ¸  = (2Ï€/params.L)^1 * diffMatrix.ğ’ŸÊ¸\ndiffMatrix.ğ’ŸÂ²Ê¸ = (2Ï€/params.L)^2 * diffMatrix.ğ’ŸÂ²Ê¸\ndiffMatrix.ğ’Ÿâ´Ê¸ = (2Ï€/params.L)^4 * diffMatrix.ğ’Ÿâ´Ê¸\n\nz1,  D1z = chebdif(params.Nz, 1)\nz2,  D2z = chebdif(params.Nz, 2)\nz3,  D3z = chebdif(params.Nz, 3)\nz4,  D4z = chebdif(params.Nz, 4)\n\n## Transform the domain and derivative operators from [-1, 1] â†’ [0, H]\ngrid.z, diffMatrix.ğ’Ÿá¶», diffMatrix.ğ’ŸÂ²á¶»  = chebder_transform(z1,  D1z,\n                                                                D2z,\n                                                                zerotoL_transform,\n                                                                params.H)\np1, q1, diffMatrix.ğ’Ÿâ´á¶» = chebder_transform_ho(z1, D1z,\n                                                D2z,\n                                                D3z,\n                                                D4z,\n                                                zerotoL_transform_ho,\n                                                params.H)\n\nreturn nothing","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"end","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"function ImplementBCs_cheb!(Op, diffMatrix, params)     IÊ¸ = sparse(Matrix(1.0I, params.Ny, params.Ny))     Iá¶» = sparse(Matrix(1.0I, params.Nz, params.Nz))","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"# Cheb matrix with Dirichilet boundary condition\n@. diffMatrix.ğ’Ÿá¶»á´°  = diffMatrix.ğ’Ÿá¶»\n@. diffMatrix.ğ’ŸÂ²á¶»á´° = diffMatrix.ğ’ŸÂ²á¶»\n@. diffMatrix.ğ’Ÿâ´á¶»á´° = diffMatrix.ğ’Ÿâ´á¶»\n\n# Cheb matrix with Neumann boundary condition\n@. diffMatrix.ğ’Ÿá¶»á´º  = diffMatrix.ğ’Ÿá¶»\n@. diffMatrix.ğ’ŸÂ²á¶»á´º = diffMatrix.ğ’ŸÂ²á¶»\n\nn = params.Nz\nfor iter âˆˆ 1:n-1\n    diffMatrix.ğ’Ÿâ´á¶»á´°[1,iter+1] = (diffMatrix.ğ’Ÿâ´á¶»á´°[1,iter+1] +\n                            -1.0 * diffMatrix.ğ’Ÿâ´á¶»á´°[1,1] * diffMatrix.ğ’ŸÂ²á¶»á´°[1,iter+1])\n\n      diffMatrix.ğ’Ÿâ´á¶»á´°[n,iter] = (diffMatrix.ğ’Ÿâ´á¶»á´°[n,iter] +\n                            -1.0 * diffMatrix.ğ’Ÿâ´á¶»á´°[n,n] * diffMatrix.ğ’ŸÂ²á¶»á´°[n,iter])\nend\n\ndiffMatrix.ğ’Ÿá¶»á´°[1,1]  = 0.0\ndiffMatrix.ğ’Ÿá¶»á´°[n,n]  = 0.0\n\ndiffMatrix.ğ’ŸÂ²á¶»á´°[1,1] = 0.0\ndiffMatrix.ğ’ŸÂ²á¶»á´°[n,n] = 0.0\n\ndiffMatrix.ğ’Ÿâ´á¶»á´°[1,1] = 0.0\ndiffMatrix.ğ’Ÿâ´á¶»á´°[n,n] = 0.0\n\n# Neumann boundary condition\n@. diffMatrix.ğ’Ÿá¶»á´º  = diffMatrix.ğ’Ÿá¶»\n@. diffMatrix.ğ’ŸÂ²á¶»á´º = diffMatrix.ğ’ŸÂ²á¶»\nfor iter âˆˆ 1:n-1\n    diffMatrix.ğ’ŸÂ²á¶»á´º[1,iter+1] = (diffMatrix.ğ’ŸÂ²á¶»á´º[1,iter+1] +\n                            -1.0 * diffMatrix.ğ’ŸÂ²á¶»á´º[1,1] * diffMatrix.ğ’Ÿá¶»á´º[1,iter+1]/diffMatrix.ğ’Ÿá¶»á´º[1,1])\n\n    diffMatrix.ğ’ŸÂ²á¶»á´º[n,iter]   = (diffMatrix.ğ’ŸÂ²á¶»á´º[n,iter] +\n                            -1.0 * diffMatrix.ğ’ŸÂ²á¶»á´º[n,n] * diffMatrix.ğ’Ÿá¶»á´º[n,iter]/diffMatrix.ğ’Ÿá¶»á´º[n,n])\nend\n\ndiffMatrix.ğ’ŸÂ²á¶»á´º[1,1] = 0.0\ndiffMatrix.ğ’ŸÂ²á¶»á´º[n,n] = 0.0\n\n@. diffMatrix.ğ’Ÿá¶»á´º[1,1:end] = 0.0\n@. diffMatrix.ğ’Ÿá¶»á´º[n,1:end] = 0.0\n\n#setBCs!(diffMatrix, params, \"dirchilet\")\n#setBCs!(diffMatrix, params, \"neumann\"  )\n\nkron!( Op.ğ’Ÿá¶»á´°  ,  IÊ¸ , diffMatrix.ğ’Ÿá¶»á´°  )\nkron!( Op.ğ’ŸÂ²á¶»á´° ,  IÊ¸ , diffMatrix.ğ’ŸÂ²á¶»á´° )\nkron!( Op.ğ’Ÿâ´á¶»á´° ,  IÊ¸ , diffMatrix.ğ’Ÿâ´á¶»á´° )\n\nkron!( Op.ğ’Ÿá¶»á´º  ,  IÊ¸ , diffMatrix.ğ’Ÿá¶»á´º )\nkron!( Op.ğ’ŸÂ²á¶»á´º ,  IÊ¸ , diffMatrix.ğ’ŸÂ²á¶»á´º)\n\nkron!( Op.ğ’ŸÊ¸   ,  diffMatrix.ğ’ŸÊ¸  ,  Iá¶» )\nkron!( Op.ğ’ŸÂ²Ê¸  ,  diffMatrix.ğ’ŸÂ²Ê¸ ,  Iá¶» )\nkron!( Op.ğ’Ÿâ´Ê¸  ,  diffMatrix.ğ’Ÿâ´Ê¸ ,  Iá¶» )\n\nkron!( Op.ğ’ŸÊ¸á¶»á´°   ,  diffMatrix.ğ’ŸÊ¸  ,  diffMatrix.ğ’Ÿá¶»á´°  )\nkron!( Op.ğ’ŸÊ¸Â²á¶»á´°  ,  diffMatrix.ğ’ŸÊ¸  ,  diffMatrix.ğ’ŸÂ²á¶»á´° )\nkron!( Op.ğ’ŸÂ²Ê¸Â²á¶»á´° ,  diffMatrix.ğ’ŸÂ²Ê¸ ,  diffMatrix.ğ’ŸÂ²á¶»á´° )\n\nreturn nothing","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"end","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"function BasicState!(diffMatrix, mf, grid, params)     Y, Z = ndgrid(grid.y, grid.z)     Y    = transpose(Y)     Z    = transpose(Z)","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"# imposed buoyancy profile\nBâ‚€   = @. 1.0/params.Î“ * Z - Y\nâˆ‚Ê¸Bâ‚€ = - 1.0 .* ones(size(Y))\nâˆ‚á¶»Bâ‚€ = 1.0/params.Î“ .* ones(size(Y))\n\nUâ‚€      = @. 1.0 * Z - 0.5params.H\nâˆ‚á¶»Uâ‚€    = ones( size(Y))\nâˆ‚Ê¸Uâ‚€    = zeros(size(Y))\n\nâˆ‚Ê¸Ê¸Uâ‚€   = zeros(size(Y))\nâˆ‚Ê¸á¶»Uâ‚€   = zeros(size(Y))\nâˆ‚á¶»á¶»Uâ‚€   = zeros(size(Y))\n\n  Bâ‚€  = Bâ‚€[:];\n  Uâ‚€  = Uâ‚€[:];\nâˆ‚Ê¸Bâ‚€  = âˆ‚Ê¸Bâ‚€[:];\nâˆ‚á¶»Bâ‚€  = âˆ‚á¶»Bâ‚€[:];\n\nâˆ‚á¶»Uâ‚€  = âˆ‚á¶»Uâ‚€[:];\nâˆ‚Ê¸Uâ‚€  = âˆ‚Ê¸Uâ‚€[:];\n\nâˆ‚Ê¸Ê¸Uâ‚€ = âˆ‚Ê¸Ê¸Uâ‚€[:];\nâˆ‚Ê¸á¶»Uâ‚€ = âˆ‚Ê¸á¶»Uâ‚€[:];\nâˆ‚á¶»á¶»Uâ‚€ = âˆ‚á¶»á¶»Uâ‚€[:];\n\nmf.Bâ‚€[diagind(mf.Bâ‚€)] = Bâ‚€\nmf.Uâ‚€[diagind(mf.Uâ‚€)] = Uâ‚€\n\nmf.âˆ‡á¶»Uâ‚€[diagind(mf.âˆ‡á¶»Uâ‚€)] = âˆ‚á¶»Uâ‚€\nmf.âˆ‡Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Uâ‚€)] = âˆ‚Ê¸Uâ‚€\n\nmf.âˆ‡Ê¸Bâ‚€[diagind(mf.âˆ‡Ê¸Bâ‚€)] = âˆ‚Ê¸Bâ‚€\nmf.âˆ‡á¶»Bâ‚€[diagind(mf.âˆ‡á¶»Bâ‚€)] = âˆ‚á¶»Bâ‚€\n\nmf.âˆ‡Ê¸Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Ê¸Uâ‚€)] = âˆ‚Ê¸Ê¸Uâ‚€;\nmf.âˆ‡á¶»á¶»Uâ‚€[diagind(mf.âˆ‡á¶»á¶»Uâ‚€)] = âˆ‚á¶»á¶»Uâ‚€;\nmf.âˆ‡Ê¸á¶»Uâ‚€[diagind(mf.âˆ‡Ê¸á¶»Uâ‚€)] = âˆ‚Ê¸á¶»Uâ‚€;\n\nreturn nothing","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"end","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"function construct_matrices(Op, mf, grid, params)\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # basic state\n    Bâ‚€   = @. 1.0/params.Î“ * Z - Y\n    âˆ‚Ê¸Bâ‚€ = - 1.0 .* ones(size(Y))\n    âˆ‚á¶»Bâ‚€ = 1.0/params.Î“ .* ones(size(Y))\n\n    Uâ‚€      = @. 1.0 * Z - 0.5params.H\n    âˆ‚á¶»Uâ‚€    = ones( size(Y))\n    âˆ‚Ê¸Uâ‚€    = zeros(size(Y))\n\n    âˆ‚Ê¸Ê¸Uâ‚€   = zeros(size(Y))\n    âˆ‚Ê¸á¶»Uâ‚€   = zeros(size(Y))\n    âˆ‚á¶»á¶»Uâ‚€   = zeros(size(Y))\n\n      Bâ‚€  = Bâ‚€[:];\n      Uâ‚€  = Uâ‚€[:];\n    âˆ‚Ê¸Bâ‚€  = âˆ‚Ê¸Bâ‚€[:];\n    âˆ‚á¶»Bâ‚€  = âˆ‚á¶»Bâ‚€[:];\n\n    âˆ‚á¶»Uâ‚€  = âˆ‚á¶»Uâ‚€[:];\n    âˆ‚Ê¸Uâ‚€  = âˆ‚Ê¸Uâ‚€[:];\n\n    âˆ‚Ê¸Ê¸Uâ‚€ = âˆ‚Ê¸Ê¸Uâ‚€[:];\n    âˆ‚Ê¸á¶»Uâ‚€ = âˆ‚Ê¸á¶»Uâ‚€[:];\n    âˆ‚á¶»á¶»Uâ‚€ = âˆ‚á¶»á¶»Uâ‚€[:];\n\n    mf.Bâ‚€[diagind(mf.Bâ‚€)] = Bâ‚€\n    mf.Uâ‚€[diagind(mf.Uâ‚€)] = Uâ‚€\n\n    mf.âˆ‡á¶»Uâ‚€[diagind(mf.âˆ‡á¶»Uâ‚€)] = âˆ‚á¶»Uâ‚€\n    mf.âˆ‡Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Uâ‚€)] = âˆ‚Ê¸Uâ‚€\n\n    mf.âˆ‡Ê¸Bâ‚€[diagind(mf.âˆ‡Ê¸Bâ‚€)] = âˆ‚Ê¸Bâ‚€\n    mf.âˆ‡á¶»Bâ‚€[diagind(mf.âˆ‡á¶»Bâ‚€)] = âˆ‚á¶»Bâ‚€\n\n    mf.âˆ‡Ê¸Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Ê¸Uâ‚€)] = âˆ‚Ê¸Ê¸Uâ‚€;\n    mf.âˆ‡á¶»á¶»Uâ‚€[diagind(mf.âˆ‡á¶»á¶»Uâ‚€)] = âˆ‚á¶»á¶»Uâ‚€;\n    mf.âˆ‡Ê¸á¶»Uâ‚€[diagind(mf.âˆ‡Ê¸á¶»Uâ‚€)] = âˆ‚Ê¸á¶»Uâ‚€;\n\n    N  = params.Ny * params.Nz\n    Iâ° = sparse(Matrix(1.0I, N, N)) #Eye{Float64}(N)\n    sâ‚ = size(Iâ°, 1); sâ‚‚ = size(Iâ°, 2)\n\n    # allocating memory for the LHS and RHS matrices\n    ğ“›â‚ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚‚ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚ƒ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n\n    â„³â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    âˆ‡â‚•Â² = SparseMatrixCSC(Zeros(N, N))\n    H   = SparseMatrixCSC(Zeros(N, N))\n\n    âˆ‡â‚•Â² = (1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.kâ‚“^2 * Iâ°)\n\n\n    H = inverse_Lap_hor(âˆ‡â‚•Â²)\n    @assert norm(âˆ‡â‚•Â² * H - Iâ°) â‰¤ 1.0e-4 \"difference in L2-norm should be small\"\n\n\n    Dâ´  = (1.0 * Op.ğ’Ÿâ´Ê¸\n        + 1.0/params.Îµ^4 * Op.ğ’Ÿâ´á¶»á´°\n        + 1.0params.kâ‚“^4 * Iâ°\n        - 2.0params.kâ‚“^2 * Op.ğ’ŸÂ²Ê¸\n        - 2.0/params.Îµ^2 * params.kâ‚“^2 * Op.ğ’ŸÂ²á¶»á´°\n        + 2.0/params.Îµ^2 * Op.ğ’ŸÂ²Ê¸Â²á¶»á´°)\n\n    DÂ²  = (1.0/params.Îµ^2 * Op.ğ’ŸÂ²á¶»á´° + 1.0 * âˆ‡â‚•Â²)\n    Dâ‚™Â² = (1.0/params.Îµ^2 * Op.ğ’ŸÂ²á¶»á´º + 1.0 * âˆ‡â‚•Â²)\n\n    # 1. uá¶» (vertical velocity)  equation (bcs: uá¶» = âˆ‚á¶»á¶»uá¶» = 0 @ z = 0, 1)\n    ğ“›â‚[:,    1:1sâ‚‚] = (-1.0params.E * Dâ´\n                    + 1.0im * params.kâ‚“ * mf.Uâ‚€ * DÂ²) * params.Îµ^2\n    ğ“›â‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0 * Op.ğ’Ÿá¶»á´º\n    ğ“›â‚[:,2sâ‚‚+1:3sâ‚‚] = -1.0 * âˆ‡â‚•Â²\n\n    # 2. Ï‰á¶» (vertical vorticity) equation (bcs: âˆ‚á¶»Ï‰á¶» = 0 @ z = 0, 1)\n    ğ“›â‚‚[:,    1:1sâ‚‚] = - 1.0 * mf.âˆ‡á¶»Uâ‚€ * Op.ğ’ŸÊ¸ - 1.0 * Op.ğ’Ÿá¶»á´°\n    ğ“›â‚‚[:,1sâ‚‚+1:2sâ‚‚] = (1.0im * params.kâ‚“ * mf.Uâ‚€ * Iâ°\n                    - 1.0params.E * Dâ‚™Â²)\n    ğ“›â‚‚[:,2sâ‚‚+1:3sâ‚‚] = 0.0 * Iâ°\n\n    # 3. b (buoyancy) equation (bcs: b = 0 @ z = 0, 1)\n    ğ“›â‚ƒ[:,    1:1sâ‚‚] = (1.0 * mf.âˆ‡á¶»Bâ‚€ * Iâ°\n                    - 1.0 * mf.âˆ‡Ê¸Bâ‚€ * H * Op.ğ’ŸÊ¸á¶»á´°)\n    ğ“›â‚ƒ[:,1sâ‚‚+1:2sâ‚‚] = 1.0im * params.kâ‚“ * mf.âˆ‡Ê¸Bâ‚€ * H * Iâ°\n    ğ“›â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = (-1.0params.E * Dâ‚™Â²\n                    + 1.0im * params.kâ‚“ * mf.Uâ‚€ * Iâ°)\n\n    ğ“› = ([ğ“›â‚; ğ“›â‚‚; ğ“›â‚ƒ]);\n\n\n    cnst = -1.0\n    â„³â‚[:,    1:1sâ‚‚] = 1.0cnst * params.Îµ^2 * DÂ²;\n    â„³â‚‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0cnst * Iâ°;\n    â„³â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = 1.0cnst * Iâ°;\n    â„³ = ([â„³â‚; â„³â‚‚; â„³â‚ƒ])\n\n    return ğ“›, â„³\nend","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"Parameters:","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"@with_kw mutable struct Params{T<:Real} @deftype T\n    L::T        = 1.0        # horizontal domain size\n    H::T        = 1.0        # vertical domain size\n    Î“::T        = 0.1        # front strength Î“ â‰¡ MÂ²/fÂ² = Î»/H = 1/Îµ â†’ Îµ = 1/Î“\n    Îµ::T        = 0.1        # aspect ratio Îµ â‰¡ H/L\n    kâ‚“::T       = 0.0        # x-wavenumber\n    E::T        = 1.0e-9     # Ekman number\n    Ny::Int64   = 48         # no. of y-grid points\n    Nz::Int64   = 24         # no. of z-grid points\n    method::String = \"krylov\"\nend\n\n\nfunction EigSolver(Op, mf, grid, params, Ïƒâ‚€)\n\n    ğ“›, â„³ = construct_matrices(Op, mf, grid, params)\n\n    N = params.Ny * params.Nz\n    MatrixSize = 3N\n    @assert size(ğ“›, 1)  == MatrixSize &&\n            size(ğ“›, 2)  == MatrixSize &&\n            size(â„³, 1)  == MatrixSize &&\n            size(â„³, 2)  == MatrixSize \"matrix size does not match!\"\n\n    if params.method == \"shift_invert\"\n        Î»â‚› = EigSolver_shift_invert( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€)\n\n    elseif params.method == \"krylov\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_krylov( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LR)\n\n\n    elseif params.method == \"arnoldi\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arnoldi( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LR)\n    end","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"======================================================================","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"    @assert length(Î»â‚›) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"||ğ“›Î§ - Î»â‚›â„³Î§||â‚‚: %f \\n\" norm(ğ“› * Î§[:,1] - Î»â‚›[1] * â„³ * Î§[:,1])\n\n    @printf \"largest growth rate : %1.4e%+1.4eim\\n\" real(Î»â‚›[1]) imag(Î»â‚›[1])\n\n    return Î»â‚›[1] #, Î§[:,1]\nend\n\n\nfunction solve_Stone1971(kâ‚“::Float64=0.0)\n    params      = Params{Float64}(kâ‚“=0.5)\n    grid        = TwoDimGrid{params.Ny,  params.Nz}()\n    diffMatrix  = ChebMarix{ params.Ny,  params.Nz}()\n    Op          = Operator{params.Ny * params.Nz}()\n    mf          = MeanFlow{params.Ny * params.Nz}()\n\n    Construct_DerivativeOperator!(diffMatrix, grid, params)\n    ImplementBCs_cheb!(Op, diffMatrix, params)\n\n    Ïƒâ‚€   = 0.01\n    params.kâ‚“ = kâ‚“\n\n    Î»â‚› = EigSolver(Op, mf, grid, params, Ïƒâ‚€)\n\n    # Analytical solution of Stone (1971) for the growth rate\n    cnst = 1.0 + 1.0/params.Î“ + 5.0*params.Îµ^2 * params.kâ‚“^2/42.0\n    Î»â‚›â‚œ = 1.0/(2.0*âˆš3.0) * (params.kâ‚“ - 2.0/15.0 * params.kâ‚“^3 * cnst)\n\n    return abs(Î»â‚›.re - Î»â‚›â‚œ) < 1e-3\n\nend\n\nsolve_Stone1971(0.1)\n\nprintln(\"Example runs OK\")","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"","category":"page"},{"location":"literated/Stone1971.html","page":"Stone1971","title":"Stone1971","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing.html#Contributors'-Guide","page":"Contributor's Guide","title":"Contributors' Guide","text":"","category":"section"},{"location":"contributing.html","page":"Contributor's Guide","title":"Contributor's Guide","text":"This is a short guide for potential BiGSTARS.jl contributors.","category":"page"},{"location":"contributing.html","page":"Contributor's Guide","title":"Contributor's Guide","text":"Please feel free to ask us questions and chat, either by raising an issue or starting a discussion.","category":"page"},{"location":"contributing.html","page":"Contributor's Guide","title":"Contributor's Guide","text":"We follow the ColPrac guide for collaborative practices.  New contributors should make sure to read that guide.","category":"page"},{"location":"modules/Ou1971.html#Baroclinic-instability","page":"-","title":"Baroclinic instability","text":"","category":"section"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu \n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b \n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"DDt equiv partialpartial t + U (partialpartial x)","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"is the material derivative, mathbfu equiv (u v epsilon w) is the velocity perturbation, epsilon=HR is the aspect ratio, p is the pressure perturbation, and b is the buoyancy perturbation. The operator ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"beginalign\n    fracDDtnabla^2 w \n    + frac1epsilon^2 fracpartial zetapartial z \n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta \n\n    fracDbDt\n    + v fracpartial Bpartial y + \n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.  The horizontal velocities u and v are related to the vertical velocity w and vertical vorticity zeta by the identities, ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"beginalign\n    nabla_h^2 u = -fracpartial zetapartial y - fracpartial^2 wpartial x partial z \n\n    nabla_h^2 v = fracpartial zetapartial x - fracpartial^2 wpartial y partial z    \nendalign","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"In deriving the above equations, we make use of the continuity equation and the definition of vertical vorticity zeta.","category":"page"},{"location":"modules/Ou1971.html#Normal-mode","page":"-","title":"Normal mode","text":"","category":"section"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"Next we consider normal-mode perturbation solutions in the form of ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew  tildezeta  tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"where the symbol mathfrakR denotes the real part and a variable with tilde' denotes an eigenfunction. The variable\\sigma=\\sigma_r + i \\sigma_i`. The real part represents the growth rate, and the imaginary part  shows the frequency of the  perturbation. ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev + \n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb \nendalign","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 +\n(1epsilon^2)partial_z^2 - k^2big)^2  textand  mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n   \n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e., ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"beginalign\n    tildew = partial_zz tildew = \n    partial_z tildezeta = partial_z tildeb = 0 \n     textat  z=0 1\nendalign","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"beginalign\n    mathsfitA mathsfX= sigma mathsfitB mathsfX   \nendalign","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"where sigma is the eigenvalue, mathsfX=tildew tildezeta tildeb^T is the eigenvector and the matrices mathsfitA, mathsfitB are the complex and real non-symmetric matrices, respectively. ","category":"page"},{"location":"modules/Ou1971.html","page":"-","title":"-","text":"(Image: Alt text)","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"\"\"\"\nThis code finds critical Rayleigh number for rotating Rayleigh Benrad Convection (rRBC)\nwhere the domain is periodic in y-direction.\nThe code is benchmarked against Chandrashekar's theoretical results.\nHydrodynamic and hydromagnetic stability by S. Chandrasekhar, 1961 (page no-95)\nparameter: Ek (Ekman number) = 10â»â´\neigenvalue: critical modified Rayleigh number (Raá¶œ) = 189.7\n\"\"\"\n# load required packages\nusing LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing ArnoldiMethod: partialschur, partialeigen, LR, LI, LM, SR\n\nusing BiGSTARS\n\n@with_kw mutable struct TwoDimGrid{Ny, Nz}\n    y = @SVector zeros(Float64, Ny)\n    z = @SVector zeros(Float64, Nz)\nend\n\n@with_kw mutable struct ChebMarix{Ny, Nz}\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n\n    ğ’Ÿá¶»::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\nend\n\n@with_kw mutable struct Operator{N}\n\"\"\"\n    `subperscript with N' means Operator with Neumann boundary condition\n        after kronker product\n    `subperscript with D' means Operator with Dirchilet boundary condition\n        after kronker product\n\"\"\"\n\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÊ¸á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’ŸÊ¸Â²á¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸Â²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\nend","category":"page"},{"location":"literated/rRBC.html#Construct-the-derivative-operator","page":"rRBC","title":"Construct the derivative operator","text":"","category":"section"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"function Construct_DerivativeOperator!(diffMatrix, grid, params)     N = params.Ny * params.Nz","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"# ------------- setup differentiation matrices  -------------------\n# Fourier in y-direction: y âˆˆ [0, L)\ny1, diffMatrix.ğ’ŸÊ¸  = FourierDiff(params.Ny, 1)\n_,  diffMatrix.ğ’ŸÂ²Ê¸ = FourierDiff(params.Ny, 2)\n_,  diffMatrix.ğ’Ÿâ´Ê¸ = FourierDiff(params.Ny, 4)\n\n# Transform the domain and derivative operators from [0, 2Ï€) â†’ [0, L)\ngrid.y         = params.L/2Ï€  * y1\ndiffMatrix.ğ’ŸÊ¸  = (2Ï€/params.L)^1 * diffMatrix.ğ’ŸÊ¸\ndiffMatrix.ğ’ŸÂ²Ê¸ = (2Ï€/params.L)^2 * diffMatrix.ğ’ŸÂ²Ê¸\ndiffMatrix.ğ’Ÿâ´Ê¸ = (2Ï€/params.L)^4 * diffMatrix.ğ’Ÿâ´Ê¸\n\n#@assert maximum(grid.y) â‰ˆ params.L && minimum(grid.y) â‰ˆ 0.0\n\n# Chebyshev in the z-direction\nz, diffMatrix.ğ’Ÿá¶»  = cheb(params.Nz-1)\ngrid.z = z\ndiffMatrix.ğ’ŸÂ²á¶» = diffMatrix.ğ’Ÿá¶»  * diffMatrix.ğ’Ÿá¶»\ndiffMatrix.ğ’Ÿâ´á¶» = diffMatrix.ğ’ŸÂ²á¶» * diffMatrix.ğ’ŸÂ²á¶»\n\n# z1, D1z = chebdif(params.Nz, 1)\n# _,  D2z = chebdif(params.Nz, 2)\n# _,  D3z = chebdif(params.Nz, 3)\n# _,  D4z = chebdif(params.Nz, 4)\n# # Transform the domain and derivative operators from [-1, 1] â†’ [0, H]\n# grid.z, diffMatrix.ğ’Ÿá¶», diffMatrix.ğ’ŸÂ²á¶»  = chebder_transform(z1,  D1z,\n#                                                                 D2z,\n#                                                                 zerotoL_transform,\n#                                                                 params.H)\n# _, _, diffMatrix.ğ’Ÿâ´á¶» = chebder_transform_ho(z1, D1z,\n#                                                 D2z,\n#                                                 D3z,\n#                                                 D4z,\n#                                                 zerotoL_transform_ho,\n#                                                 params.H)\n\n#@printf \"size of Chebyshev matrix: %d Ã— %d \\n\" size(diffMatrix.ğ’Ÿá¶»)[1]  size(diffMatrix.ğ’Ÿá¶»)[2]\n\n@assert maximum(grid.z) â‰ˆ params.H && minimum(grid.z) â‰ˆ 0.0\n\nreturn nothing","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"end","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"function ImplementBCs_cheb!(Op, diffMatrix, params)     IÊ¸ = sparse(Matrix(1.0I, params.Ny, params.Ny)) #Eye{Float64}(params.Ny)     Iá¶» = sparse(Matrix(1.0I, params.Nz, params.Nz)) #Eye{Float64}(params.Nz)","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"# Cheb matrix with Dirichilet boundary condition\ndiffMatrix.ğ’Ÿá¶»á´°  = deepcopy( diffMatrix.ğ’Ÿá¶»  )\ndiffMatrix.ğ’ŸÂ²á¶»á´° = deepcopy( diffMatrix.ğ’ŸÂ²á¶» )\ndiffMatrix.ğ’Ÿâ´á¶»á´° = deepcopy( diffMatrix.ğ’Ÿâ´á¶» )\n\n# Cheb matrix with Neumann boundary condition\ndiffMatrix.ğ’Ÿá¶»á´º  = deepcopy( diffMatrix.ğ’Ÿá¶»  )\ndiffMatrix.ğ’ŸÂ²á¶»á´º = deepcopy( diffMatrix.ğ’ŸÂ²á¶» )\n\nsetBCs!(diffMatrix, params, \"dirchilet\")\nsetBCs!(diffMatrix, params, \"neumann\"  )\n\nkron!( Op.ğ’Ÿá¶»á´°  ,  IÊ¸ , diffMatrix.ğ’Ÿá¶»á´°  )\nkron!( Op.ğ’ŸÂ²á¶»á´° ,  IÊ¸ , diffMatrix.ğ’ŸÂ²á¶»á´° )\nkron!( Op.ğ’Ÿâ´á¶»á´° ,  IÊ¸ , diffMatrix.ğ’Ÿâ´á¶»á´° )\n\nkron!( Op.ğ’Ÿá¶»á´º  ,  IÊ¸ , diffMatrix.ğ’Ÿá¶»á´º )\nkron!( Op.ğ’ŸÂ²á¶»á´º ,  IÊ¸ , diffMatrix.ğ’ŸÂ²á¶»á´º)\n\nkron!( Op.ğ’ŸÊ¸   ,  diffMatrix.ğ’ŸÊ¸  ,  Iá¶» )\nkron!( Op.ğ’ŸÂ²Ê¸  ,  diffMatrix.ğ’ŸÂ²Ê¸ ,  Iá¶» )\nkron!( Op.ğ’Ÿâ´Ê¸  ,  diffMatrix.ğ’Ÿâ´Ê¸ ,  Iá¶» )\n\nkron!( Op.ğ’ŸÊ¸Â²á¶»á´°  ,  diffMatrix.ğ’ŸÊ¸  ,  diffMatrix.ğ’ŸÂ²á¶»á´° )\nkron!( Op.ğ’ŸÂ²Ê¸Â²á¶»á´° ,  diffMatrix.ğ’ŸÂ²Ê¸ ,  diffMatrix.ğ’ŸÂ²á¶»á´° )\n\nreturn nothing","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"end","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"function construct_matrices(Op, params)\n    N  = params.Ny * params.Nz\n    Iâ° = sparse(Matrix(1.0I, N, N)) #Eye{Float64}(N)\n    sâ‚ = size(Iâ°, 1); sâ‚‚ = size(Iâ°, 2)","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"allocating memory for the LHS and RHS matrices","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"    ğ“›â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    â„³â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    @printf \"Start constructing matrices \\n\"","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“ construct matrix  â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“ lhs of the matrix (size := 3 Ã— 3) eigenvectors: [uá¶» Ï‰á¶» Î¸]áµ€","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"    âˆ‡â‚•Â² = SparseMatrixCSC(Zeros(N, N))\n    âˆ‡â‚•Â² = (1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.kâ‚“^2 * Iâ°)\n\n    Dâ´ = (1.0 * Op.ğ’Ÿâ´Ê¸ + 1.0 * Op.ğ’Ÿâ´á¶»á´° + 2.0 * Op.ğ’ŸÂ²Ê¸Â²á¶»á´°\n        + 1.0 * params.kâ‚“^4 * Iâ°\n        - 2.0 * params.kâ‚“^2 * Op.ğ’ŸÂ²Ê¸\n        - 2.0 * params.kâ‚“^2 * Op.ğ’ŸÂ²á¶»á´°)\n\n    DÂ²  = 1.0 * Op.ğ’ŸÂ²á¶»á´° + 1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.kâ‚“^2 * Iâ°\n    Dâ‚™Â² = 1.0 * Op.ğ’ŸÂ²á¶»á´º + 1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.kâ‚“^2 * Iâ°\n\n    # 1. uá¶» (vertical velocity) equation\n    ğ“›â‚[:,    1:1sâ‚‚] =  1.0 * params.E * Dâ´\n    ğ“›â‚[:,1sâ‚‚+1:2sâ‚‚] = -1.0 * Op.ğ’Ÿá¶»á´º\n    ğ“›â‚[:,2sâ‚‚+1:3sâ‚‚] =  0.0 * Iâ°\n\n    # 2. Ï‰á¶» (vertical vorticity) equation\n    ğ“›â‚‚[:,    1:1sâ‚‚] = 1.0 * Op.ğ’Ÿá¶»á´°\n    ğ“›â‚‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0 * params.E * Dâ‚™Â²\n    ğ“›â‚‚[:,2sâ‚‚+1:3sâ‚‚] = 0.0 * Iâ°\n\n    # 3. Î¸ (temperature) equation\n    ğ“›â‚ƒ[:,    1:1sâ‚‚] = 1.0 * Iâ°\n    ğ“›â‚ƒ[:,1sâ‚‚+1:2sâ‚‚] = 0.0 * Iâ°\n    ğ“›â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = 1.0 * DÂ²\n\n    ğ“› = ([ğ“›â‚; ğ“›â‚‚; ğ“›â‚ƒ]);\n\n##############\n    â„³â‚[:,2sâ‚‚+1:3sâ‚‚] = -1.0 * âˆ‡â‚•Â²\n\n    â„³ = ([â„³â‚; â„³â‚‚; â„³â‚ƒ])\n\n    return ğ“›, â„³\nend\n\n@with_kw mutable struct Params{T<:Real} @deftype T\n    L::T        = 2Ï€          # horizontal domain size\n    H::T        = 1.0         # vertical domain size\n    Î“::T        = 0.1         # front strength Î“ â‰¡ MÂ²/fÂ² = Î»/H = 1/Îµ â†’ Îµ = 1/Î“\n    Îµ::T        = 0.1         # aspect ratio Îµ â‰¡ H/L\n    kâ‚“::T       = 0.0         # x-wavenumber\n    E::T        = 1.0e-4      # Ekman number\n    Ny::Int64   = 180         # no. of y-grid points\n    Nz::Int64   = 20          # no. of z-grid points\n    method::String   = \"arnoldi\"\nend\n\nfunction EigSolver(Op, params, Ïƒâ‚€)\n\n    printstyled(\"kâ‚“: $(params.kâ‚“) \\n\"; color=:blue)\n\n    ğ“›, â„³ = construct_matrices(Op,  params)\n\n    N = params.Ny * params.Nz\n    MatrixSize = 3N\n    @assert size(ğ“›, 1)  == MatrixSize &&\n            size(ğ“›, 2)  == MatrixSize &&\n            size(â„³, 1)  == MatrixSize &&\n            size(â„³, 2)  == MatrixSize \"matrix size does not match!\"\n\n    if params.method == \"shift_invert\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arpack( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LM)\n\n    elseif params.method == \"krylov\"\n\n         Î»â‚›, Î§ = EigSolver_shift_invert_krylov( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LM)\n\n    elseif params.method == \"arnoldi\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arnoldi( ğ“›, â„³,\n                                            Ïƒâ‚€=0.0,\n                                            maxiter=50000,\n                                            which=LM())\n\n        Î»â‚›, Î§ = remove_evals(Î»â‚›, Î§, 10.0, 1.0e15, \"R\")\n        Î»â‚›, Î§ = sort_evals(Î»â‚›, Î§, \"R\", \"\")\n\n    end\n\n    return Î»â‚›[1] #, Î§[:,1]\nend\n\nfunction solve_rRBC(kâ‚“::Float64)\n    params      = Params{Float64}(kâ‚“=0.5)\n    grid        = TwoDimGrid{params.Ny,  params.Nz}()\n    diffMatrix  = ChebMarix{ params.Ny,  params.Nz}()\n    Op          = Operator{params.Ny * params.Nz}()\n    Construct_DerivativeOperator!(diffMatrix, grid, params)\n    ImplementBCs_cheb!(Op, diffMatrix, params)\n\n    Ïƒâ‚€   = 0.0\n    params.kâ‚“ = kâ‚“\n\n    Î»â‚› = EigSolver(Op, params, Ïƒâ‚€)\n\n    # Theoretical results from Chandrashekar (1961)\n    Î»â‚›â‚œ = 189.7\n\n    return abs(real(Î»â‚›) - Î»â‚›â‚œ)/Î»â‚›â‚œ < 1e-4\n\nend\n\nsolve_rRBC(0.0)","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"","category":"page"},{"location":"literated/rRBC.html","page":"rRBC","title":"rRBC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html#BiGSTARS.jl-Documentation","page":"Home","title":"BiGSTARS.jl Documentation","text":"","category":"section"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"BiGSTARS.jl is a collection of modules to provide solvers for problems in Geophysical Fluid Dynamics, on periodic domains using Fourier-based pseudospectral methods.","category":"page"},{"location":"index.html#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Examples aim to demonstrate the main functionalities of each module.  Have a look at our Examples collection!","category":"page"}]
}
